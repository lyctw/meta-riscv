From 33e01c3cdfc0a6811f3941d08b579f399d4158db Mon Sep 17 00:00:00 2001
From: Yu Chien Peter Lin <peterlin@andestech.com>
Date: Sat, 26 Aug 2023 20:45:40 +0800
Subject: [PATCH] !!!DROP!!! Add fdt pmu debug messsages

Upstream-Status: Pending
---
 lib/utils/fdt/fdt_pmu.c | 42 +++++++++++++++++++++++++----------------
 1 file changed, 26 insertions(+), 16 deletions(-)

diff --git a/lib/utils/fdt/fdt_pmu.c b/lib/utils/fdt/fdt_pmu.c
index 83301bb..86f0e44 100644
--- a/lib/utils/fdt/fdt_pmu.c
+++ b/lib/utils/fdt/fdt_pmu.c
@@ -11,6 +11,7 @@
 #include <libfdt.h>
 #include <sbi/sbi_hart.h>
 #include <sbi/sbi_error.h>
+#include <sbi/sbi_console.h>
 #include <sbi/sbi_pmu.h>
 #include <sbi/sbi_scratch.h>
 #include <sbi_utils/fdt/fdt_helper.h>
@@ -32,8 +33,11 @@ uint64_t fdt_pmu_get_select_value(uint32_t event_idx)
 
 	for (i = 0; i < SBI_PMU_HW_EVENT_MAX; i++) {
 		event = &fdt_pmu_evt_select[i];
-		if (event->eidx == event_idx)
+		if (event->eidx == event_idx) {
+			sbi_printf("%s: event idx %#x => select: %#lx\n",
+				__func__, event_idx, event->select);
 			return event->select;
+		}
 	}
 
 	return 0;
@@ -41,21 +45,21 @@ uint64_t fdt_pmu_get_select_value(uint32_t event_idx)
 
 int fdt_pmu_fixup(void *fdt)
 {
-	int pmu_offset;
-	struct sbi_scratch *scratch = sbi_scratch_thishart_ptr();
-
-	if (!fdt)
-		return SBI_EINVAL;
-
-	pmu_offset = fdt_node_offset_by_compatible(fdt, -1, "riscv,pmu");
-	if (pmu_offset < 0)
-		return SBI_EFAIL;
-
-	fdt_delprop(fdt, pmu_offset, "riscv,event-to-mhpmcounters");
-	fdt_delprop(fdt, pmu_offset, "riscv,event-to-mhpmevent");
-	fdt_delprop(fdt, pmu_offset, "riscv,raw-event-to-mhpmcounters");
-	if (!sbi_hart_has_extension(scratch, SBI_HART_EXT_SSCOFPMF))
-		fdt_delprop(fdt, pmu_offset, "interrupts-extended");
+//	int pmu_offset;
+//	struct sbi_scratch *scratch = sbi_scratch_thishart_ptr();
+//
+//	if (!fdt)
+//		return SBI_EINVAL;
+//
+//	pmu_offset = fdt_node_offset_by_compatible(fdt, -1, "riscv,pmu");
+//	if (pmu_offset < 0)
+//		return SBI_EFAIL;
+//
+//	fdt_delprop(fdt, pmu_offset, "riscv,event-to-mhpmcounters");
+//	fdt_delprop(fdt, pmu_offset, "riscv,event-to-mhpmevent");
+//	fdt_delprop(fdt, pmu_offset, "riscv,raw-event-to-mhpmcounters");
+//	if (!sbi_hart_has_extension(scratch, SBI_HART_EXT_SSCOFPMF))
+//		fdt_delprop(fdt, pmu_offset, "interrupts-extended");
 
 	return 0;
 }
@@ -80,6 +84,8 @@ int fdt_pmu_setup(void *fdt)
 				    "riscv,event-to-mhpmcounters", &len);
 	if (event_ctr_map && len >= 8) {
 		len = len / (sizeof(u32) * 3);
+		sbi_printf("%s: riscv,event-to-mhpmcounters has %d entries\n",
+			__func__, len);
 		for (i = 0; i < len; i++) {
 			event_idx_start = fdt32_to_cpu(event_ctr_map[3 * i]);
 			event_idx_end = fdt32_to_cpu(event_ctr_map[3 * i + 1]);
@@ -95,6 +101,8 @@ int fdt_pmu_setup(void *fdt)
 				"riscv,event-to-mhpmevent", &len);
 	if (event_val && len >= 8) {
 		len = len / (sizeof(u32) * 3);
+		sbi_printf("%s: riscv,event-to-mhpmevent has %d entries\n",
+			__func__, len);
 		for (i = 0; i < len; i++) {
 			event = &fdt_pmu_evt_select[hw_event_count];
 			event->eidx = fdt32_to_cpu(event_val[3 * i]);
@@ -109,6 +117,8 @@ int fdt_pmu_setup(void *fdt)
 				"riscv,raw-event-to-mhpmcounters", &len);
 	if (event_val && len >= 20) {
 		len = len / (sizeof(u32) * 5);
+		sbi_printf("%s: riscv,raw-event-to-mhpmcounters has %d entries\n",
+			__func__, len);
 		for (i = 0; i < len; i++) {
 			raw_selector = fdt32_to_cpu(event_val[5 * i]);
 			raw_selector = (raw_selector << 32) |
-- 
2.34.1

