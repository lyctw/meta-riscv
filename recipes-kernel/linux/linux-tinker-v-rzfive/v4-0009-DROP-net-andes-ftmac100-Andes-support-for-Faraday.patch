From b42fcc932b59b1f94ba55c5d703db34eb0caca10 Mon Sep 17 00:00:00 2001
From: Alan Kao <alankao@andestech.com>
Date: Tue, 3 Sep 2019 11:22:10 +0800
Subject: [PATCH v4 09/18] !!!DROP!!! net: andes: ftmac100: Andes support for
 Faraday ATCMAC

Reformed from the following patches on RISCV-Linux-5.4:
- (604c07b887a1) Andes support for Faraday ATCMAC
- (d61585d8b2a5) ftmac100.c: fix deprecated API
- (7c0206d07793) driver/net/ethernet/faraday: Support 64bit mac driver.
- (bb889b5a0d27) faraday/ftmac100.c: Solve NIC RPKT_LOST & NORXBUF issue
- (86aca052be66) driver/net/ethernet/faraday: Add ftmac100_debug control.
- (133384ba074a) faraday/ftmac100.c: Support FTMAC100 with suspend & resume functions.

Signed-off-by: Alan Kao <alankao@andestech.com>
Signed-off-by: Yu Chien Peter Lin <peterlin@andestech.com>
Signed-off-by: Charles Ci-Jyun Wu <dminus@andestech.com>
---
 drivers/net/ethernet/faraday/Kconfig          |   8 +-
 drivers/net/ethernet/faraday/Makefile         |   2 +-
 drivers/net/ethernet/faraday/ftmac100.c       | 234 +++++++++++++-----
 drivers/net/ethernet/faraday/ftmac100.h       |  75 +++---
 drivers/net/ethernet/faraday/ftmac100_debug.c | 193 +++++++++++++++
 5 files changed, 409 insertions(+), 103 deletions(-)
 create mode 100644 drivers/net/ethernet/faraday/ftmac100_debug.c

diff --git a/drivers/net/ethernet/faraday/Kconfig b/drivers/net/ethernet/faraday/Kconfig
index c699bd6bcbb9..1c12978ab8b0 100644
--- a/drivers/net/ethernet/faraday/Kconfig
+++ b/drivers/net/ethernet/faraday/Kconfig
@@ -6,7 +6,7 @@
 config NET_VENDOR_FARADAY
 	bool "Faraday devices"
 	default y
-	depends on ARM || COMPILE_TEST
+	depends on ARM || RISCV || COMPILE_TEST
 	help
 	  If you have a network (Ethernet) card belonging to this class, say Y.
 
@@ -19,12 +19,12 @@ if NET_VENDOR_FARADAY
 
 config FTMAC100
 	tristate "Faraday FTMAC100 10/100 Ethernet support"
-	depends on ARM || COMPILE_TEST
-	depends on !64BIT || BROKEN
+	depends on ARM || RISCV || COMPILE_TEST
 	select MII
 	help
 	  This driver supports the FTMAC100 10/100 Ethernet controller
-	  from Faraday. It is used on Faraday A320 and some other ARM SoC's.
+	  from Faraday. It is used on Faraday A320, Andes AG101 and some
+	  other ARM/RISCV SoC's.
 
 config FTGMAC100
 	tristate "Faraday FTGMAC100 Gigabit Ethernet support"
diff --git a/drivers/net/ethernet/faraday/Makefile b/drivers/net/ethernet/faraday/Makefile
index f16f58467868..950f34d5e86f 100644
--- a/drivers/net/ethernet/faraday/Makefile
+++ b/drivers/net/ethernet/faraday/Makefile
@@ -4,4 +4,4 @@
 #
 
 obj-$(CONFIG_FTGMAC100) += ftgmac100.o
-obj-$(CONFIG_FTMAC100) += ftmac100.o
+obj-$(CONFIG_FTMAC100) += ftmac100.o ftmac100_debug.o
diff --git a/drivers/net/ethernet/faraday/ftmac100.c b/drivers/net/ethernet/faraday/ftmac100.c
index 139fe66f8bcd..2719a5a82d2b 100644
--- a/drivers/net/ethernet/faraday/ftmac100.c
+++ b/drivers/net/ethernet/faraday/ftmac100.c
@@ -4,6 +4,19 @@
  *
  * (C) Copyright 2009-2011 Faraday Technology
  * Po-Yu Chuang <ratbert@faraday-tech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
  */
 
 #define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
@@ -40,12 +53,29 @@
 #error invalid RX_BUF_SIZE
 #endif
 
+#define xprintk(...)
+
+#define FTMAC100_RX_DESC(priv, index)     (&priv->descs->rxdes[index])
+#define FTMAC100_RX_DESC_EXT(priv, index) (&priv->descs->rxdes_ext[index])
+#define FTMAC100_TX_DESC(priv, index)     (&priv->descs->txdes[index])
+#define FTMAC100_TX_DESC_EXT(priv, index) (&priv->descs->txdes_ext[index])
+
+#define FTMAC100_CURRENT_RX_DESC_INDEX(priv) (priv->rx_pointer)
+#define FTMAC100_CURRENT_TX_DESC_INDEX(priv) (priv->tx_pointer);
+#define FTMAC100_CURRENT_CLEAN_TX_DESC_INDEX(priv) (priv->tx_clean_pointer);
+
+/* ftmac100_debug parameters */
+extern unsigned int FTMAC100_DEBUG;
+extern unsigned int FTMAC100_INCR;
+
 /******************************************************************************
  * private data
  *****************************************************************************/
 struct ftmac100_descs {
 	struct ftmac100_rxdes rxdes[RX_QUEUE_ENTRIES];
 	struct ftmac100_txdes txdes[TX_QUEUE_ENTRIES];
+	struct ftmac100_rxdes_ext rxdes_ext[RX_QUEUE_ENTRIES];
+	struct ftmac100_txdes_ext txdes_ext[TX_QUEUE_ENTRIES];
 };
 
 struct ftmac100 {
@@ -71,7 +101,7 @@ struct ftmac100 {
 };
 
 static int ftmac100_alloc_rx_page(struct ftmac100 *priv,
-				  struct ftmac100_rxdes *rxdes, gfp_t gfp);
+				  int index, gfp_t gfp);
 
 /******************************************************************************
  * internal functions (hardware register access)
@@ -98,11 +128,13 @@ static void ftmac100_disable_all_int(struct ftmac100 *priv)
 
 static void ftmac100_set_rx_ring_base(struct ftmac100 *priv, dma_addr_t addr)
 {
+	xprintk("%s: addr %p\n", __func__, (void *)addr);
 	iowrite32(addr, priv->base + FTMAC100_OFFSET_RXR_BADR);
 }
 
 static void ftmac100_set_tx_ring_base(struct ftmac100 *priv, dma_addr_t addr)
 {
+	xprintk("%s: addr %p\n", __func__, (void *)addr);
 	iowrite32(addr, priv->base + FTMAC100_OFFSET_TXR_BADR);
 }
 
@@ -176,6 +208,19 @@ static int ftmac100_start_hw(struct ftmac100 *priv)
 
 	iowrite32(FTMAC100_APTC_RXPOLL_CNT(1), priv->base + FTMAC100_OFFSET_APTC);
 
+	// Enable DMA Burst & RXFIFO threshold
+	iowrite32(FTMAC100_DBLAC_RX_THR_EN	|  /* Enable fifo threshold arb */
+		  FTMAC100_DBLAC_INCR16_EN	|  /* Enable INCR[4/8/16] DMA Burst,
+						      this option solve RX RPKT_LOST issue */
+		  FTMAC100_DBLAC_RXFIFO_HTHR(6) |  /* 6/8 of FIFO high threshold */
+		  FTMAC100_DBLAC_RXFIFO_LTHR(2),   /* 2/8 of FIFO low threshold */
+		  priv->base + FTMAC100_OFFSET_DBLAC);
+
+	// Pending interrupt until receive packets reach threshold
+	iowrite32(FTMAC100_ITC_RXINT_THR(1) |
+		  FTMAC100_ITC_TXINT_THR(1),
+		  priv->base + FTMAC100_OFFSET_ITC);
+
 	ftmac100_set_mac(priv, netdev->dev_addr);
 
 	 /* See ftmac100_change_mtu() */
@@ -267,25 +312,22 @@ static void ftmac100_rxdes_set_dma_addr(struct ftmac100_rxdes *rxdes,
 					dma_addr_t addr)
 {
 	rxdes->rxdes2 = cpu_to_le32(addr);
+	rxdes->rxdes3 = cpu_to_le32(addr >> 32);
 }
 
 static dma_addr_t ftmac100_rxdes_get_dma_addr(struct ftmac100_rxdes *rxdes)
 {
-	return le32_to_cpu(rxdes->rxdes2);
+	return le32_to_cpu(rxdes->rxdes2) | (dma_addr_t)le32_to_cpu(rxdes->rxdes3) << 32;
 }
 
-/*
- * rxdes3 is not used by hardware. We use it to keep track of page.
- * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().
- */
-static void ftmac100_rxdes_set_page(struct ftmac100_rxdes *rxdes, struct page *page)
+static void ftmac100_rxdes_set_page(struct ftmac100 *priv, int index, struct page *page)
 {
-	rxdes->rxdes3 = (unsigned int)page;
+	FTMAC100_RX_DESC_EXT(priv, index)->page = page;
 }
 
-static struct page *ftmac100_rxdes_get_page(struct ftmac100_rxdes *rxdes)
+static struct page *ftmac100_rxdes_get_page(struct ftmac100 *priv, int index)
 {
-	return (struct page *)rxdes->rxdes3;
+	return (struct page *)FTMAC100_RX_DESC_EXT(priv, index)->page;
 }
 
 /******************************************************************************
@@ -301,26 +343,23 @@ static void ftmac100_rx_pointer_advance(struct ftmac100 *priv)
 	priv->rx_pointer = ftmac100_next_rx_pointer(priv->rx_pointer);
 }
 
-static struct ftmac100_rxdes *ftmac100_current_rxdes(struct ftmac100 *priv)
-{
-	return &priv->descs->rxdes[priv->rx_pointer];
-}
-
-static struct ftmac100_rxdes *
+static int
 ftmac100_rx_locate_first_segment(struct ftmac100 *priv)
 {
-	struct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);
+	int index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+	struct ftmac100_rxdes *rxdes = FTMAC100_RX_DESC(priv, index);
 
 	while (!ftmac100_rxdes_owned_by_dma(rxdes)) {
 		if (ftmac100_rxdes_first_segment(rxdes))
-			return rxdes;
+			return index;
 
 		ftmac100_rxdes_set_dma_own(rxdes);
 		ftmac100_rx_pointer_advance(priv);
-		rxdes = ftmac100_current_rxdes(priv);
+		index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+		rxdes = FTMAC100_RX_DESC(priv, index);
 	}
 
-	return NULL;
+	return -1;
 }
 
 static bool ftmac100_rx_packet_error(struct ftmac100 *priv,
@@ -370,9 +409,13 @@ static bool ftmac100_rx_packet_error(struct ftmac100 *priv,
 static void ftmac100_rx_drop_packet(struct ftmac100 *priv)
 {
 	struct net_device *netdev = priv->netdev;
-	struct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);
+	struct ftmac100_rxdes *rxdes;
+	int index;
 	bool done = false;
 
+	index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+	rxdes = FTMAC100_RX_DESC(priv, index);
+
 	if (net_ratelimit())
 		netdev_dbg(netdev, "drop packet %p\n", rxdes);
 
@@ -382,7 +425,8 @@ static void ftmac100_rx_drop_packet(struct ftmac100 *priv)
 
 		ftmac100_rxdes_set_dma_own(rxdes);
 		ftmac100_rx_pointer_advance(priv);
-		rxdes = ftmac100_current_rxdes(priv);
+		index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+		rxdes = FTMAC100_RX_DESC(priv, index);
 	} while (!done && !ftmac100_rxdes_owned_by_dma(rxdes));
 
 	netdev->stats.rx_dropped++;
@@ -396,11 +440,13 @@ static bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)
 	struct page *page;
 	dma_addr_t map;
 	int length;
+	int index;
 	bool ret;
 
-	rxdes = ftmac100_rx_locate_first_segment(priv);
-	if (!rxdes)
+	index = ftmac100_rx_locate_first_segment(priv);
+	if (index < 0)
 		return false;
+	rxdes = FTMAC100_RX_DESC(priv, index);
 
 	if (unlikely(ftmac100_rx_packet_error(priv, rxdes))) {
 		ftmac100_rx_drop_packet(priv);
@@ -432,7 +478,7 @@ static bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)
 	dma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);
 
 	length = ftmac100_rxdes_frame_length(rxdes);
-	page = ftmac100_rxdes_get_page(rxdes);
+	page = ftmac100_rxdes_get_page(priv, index);
 	skb_fill_page_desc(skb, 0, page, 0, length);
 	skb->len += length;
 	skb->data_len += length;
@@ -445,7 +491,7 @@ static bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)
 		/* Small frames are copied into linear part to free one page */
 		__pskb_pull_tail(skb, length);
 	}
-	ftmac100_alloc_rx_page(priv, rxdes, GFP_ATOMIC);
+	ftmac100_alloc_rx_page(priv, index, GFP_ATOMIC);
 
 	ftmac100_rx_pointer_advance(priv);
 
@@ -528,25 +574,27 @@ static void ftmac100_txdes_set_dma_addr(struct ftmac100_txdes *txdes,
 					dma_addr_t addr)
 {
 	txdes->txdes2 = cpu_to_le32(addr);
+	txdes->txdes3 = cpu_to_le32(addr >> 32);
 }
 
 static dma_addr_t ftmac100_txdes_get_dma_addr(struct ftmac100_txdes *txdes)
 {
-	return le32_to_cpu(txdes->txdes2);
+	return le32_to_cpu(txdes->txdes2) | (dma_addr_t)le32_to_cpu(txdes->txdes3) << 32;
 }
 
-/*
- * txdes3 is not used by hardware. We use it to keep track of socket buffer.
- * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().
- */
-static void ftmac100_txdes_set_skb(struct ftmac100_txdes *txdes, struct sk_buff *skb)
+static void ftmac100_txdes_skb_reset(struct ftmac100 *priv, int index)
+{
+	FTMAC100_TX_DESC_EXT(priv, index)->skb = NULL;
+}
+
+static void ftmac100_txdes_set_skb(struct ftmac100 *priv, int index, struct sk_buff *skb)
 {
-	txdes->txdes3 = (unsigned int)skb;
+	FTMAC100_TX_DESC_EXT(priv, index)->skb = skb;
 }
 
-static struct sk_buff *ftmac100_txdes_get_skb(struct ftmac100_txdes *txdes)
+static struct sk_buff *ftmac100_txdes_get_skb(struct ftmac100 *priv, int index)
 {
-	return (struct sk_buff *)txdes->txdes3;
+	return (struct sk_buff *)FTMAC100_TX_DESC_EXT(priv, index)->skb;
 }
 
 /******************************************************************************
@@ -567,32 +615,24 @@ static void ftmac100_tx_clean_pointer_advance(struct ftmac100 *priv)
 	priv->tx_clean_pointer = ftmac100_next_tx_pointer(priv->tx_clean_pointer);
 }
 
-static struct ftmac100_txdes *ftmac100_current_txdes(struct ftmac100 *priv)
-{
-	return &priv->descs->txdes[priv->tx_pointer];
-}
-
-static struct ftmac100_txdes *ftmac100_current_clean_txdes(struct ftmac100 *priv)
-{
-	return &priv->descs->txdes[priv->tx_clean_pointer];
-}
-
 static bool ftmac100_tx_complete_packet(struct ftmac100 *priv)
 {
 	struct net_device *netdev = priv->netdev;
 	struct ftmac100_txdes *txdes;
 	struct sk_buff *skb;
 	dma_addr_t map;
+	int index;
 
 	if (priv->tx_pending == 0)
 		return false;
 
-	txdes = ftmac100_current_clean_txdes(priv);
+	index = FTMAC100_CURRENT_CLEAN_TX_DESC_INDEX(priv);
+	txdes = FTMAC100_TX_DESC(priv, index);
 
 	if (ftmac100_txdes_owned_by_dma(txdes))
 		return false;
 
-	skb = ftmac100_txdes_get_skb(txdes);
+	skb = ftmac100_txdes_get_skb(priv, index);
 	map = ftmac100_txdes_get_dma_addr(txdes);
 
 	if (unlikely(ftmac100_txdes_excessive_collision(txdes) ||
@@ -611,6 +651,7 @@ static bool ftmac100_tx_complete_packet(struct ftmac100 *priv)
 	dev_kfree_skb(skb);
 
 	ftmac100_txdes_reset(txdes);
+	ftmac100_txdes_skb_reset(priv, index);
 
 	ftmac100_tx_clean_pointer_advance(priv);
 
@@ -628,18 +669,20 @@ static void ftmac100_tx_complete(struct ftmac100 *priv)
 		;
 }
 
-static netdev_tx_t ftmac100_xmit(struct ftmac100 *priv, struct sk_buff *skb,
-				 dma_addr_t map)
+static int ftmac100_xmit(struct ftmac100 *priv, struct sk_buff *skb,
+			 dma_addr_t map)
 {
 	struct net_device *netdev = priv->netdev;
 	struct ftmac100_txdes *txdes;
 	unsigned int len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;
+	int index;
 
-	txdes = ftmac100_current_txdes(priv);
+	index = FTMAC100_CURRENT_TX_DESC_INDEX(priv);
+	txdes = FTMAC100_TX_DESC(priv, index);
 	ftmac100_tx_pointer_advance(priv);
 
 	/* setup TX descriptor */
-	ftmac100_txdes_set_skb(txdes, skb);
+	ftmac100_txdes_set_skb(priv, index, skb);
 	ftmac100_txdes_set_dma_addr(txdes, map);
 
 	ftmac100_txdes_set_first_segment(txdes);
@@ -664,9 +707,10 @@ static netdev_tx_t ftmac100_xmit(struct ftmac100 *priv, struct sk_buff *skb,
  * internal functions (buffer)
  *****************************************************************************/
 static int ftmac100_alloc_rx_page(struct ftmac100 *priv,
-				  struct ftmac100_rxdes *rxdes, gfp_t gfp)
+				  int index, gfp_t gfp)
 {
 	struct net_device *netdev = priv->netdev;
+	struct ftmac100_rxdes *rxdes = FTMAC100_RX_DESC(priv, index);
 	struct page *page;
 	dma_addr_t map;
 
@@ -685,7 +729,7 @@ static int ftmac100_alloc_rx_page(struct ftmac100 *priv,
 		return -ENOMEM;
 	}
 
-	ftmac100_rxdes_set_page(rxdes, page);
+	ftmac100_rxdes_set_page(priv, index, page);
 	ftmac100_rxdes_set_dma_addr(rxdes, map);
 	ftmac100_rxdes_set_buffer_size(rxdes, RX_BUF_SIZE);
 	ftmac100_rxdes_set_dma_own(rxdes);
@@ -697,8 +741,8 @@ static void ftmac100_free_buffers(struct ftmac100 *priv)
 	int i;
 
 	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
-		struct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];
-		struct page *page = ftmac100_rxdes_get_page(rxdes);
+		struct ftmac100_rxdes *rxdes = FTMAC100_RX_DESC(priv, i);
+		struct page *page = ftmac100_rxdes_get_page(priv, i);
 		dma_addr_t map = ftmac100_rxdes_get_dma_addr(rxdes);
 
 		if (!page)
@@ -709,8 +753,8 @@ static void ftmac100_free_buffers(struct ftmac100 *priv)
 	}
 
 	for (i = 0; i < TX_QUEUE_ENTRIES; i++) {
-		struct ftmac100_txdes *txdes = &priv->descs->txdes[i];
-		struct sk_buff *skb = ftmac100_txdes_get_skb(txdes);
+		struct ftmac100_txdes *txdes = FTMAC100_TX_DESC(priv, i);
+		struct sk_buff *skb = ftmac100_txdes_get_skb(priv, i);
 		dma_addr_t map = ftmac100_txdes_get_dma_addr(txdes);
 
 		if (!skb)
@@ -730,7 +774,8 @@ static int ftmac100_alloc_buffers(struct ftmac100 *priv)
 
 	priv->descs = dma_alloc_coherent(priv->dev,
 					 sizeof(struct ftmac100_descs),
-					 &priv->descs_dma_addr, GFP_KERNEL);
+					 &priv->descs_dma_addr,
+					 GFP_KERNEL);
 	if (!priv->descs)
 		return -ENOMEM;
 
@@ -738,9 +783,7 @@ static int ftmac100_alloc_buffers(struct ftmac100 *priv)
 	ftmac100_rxdes_set_end_of_ring(&priv->descs->rxdes[RX_QUEUE_ENTRIES - 1]);
 
 	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
-		struct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];
-
-		if (ftmac100_alloc_rx_page(priv, rxdes, GFP_KERNEL))
+		if (ftmac100_alloc_rx_page(priv, i, GFP_KERNEL))
 			goto err;
 	}
 
@@ -917,7 +960,7 @@ static int ftmac100_poll(struct napi_struct *napi, int budget)
 
 	if (status & (FTMAC100_INT_NORXBUF | FTMAC100_INT_RPKT_LOST |
 		      FTMAC100_INT_AHB_ERR | FTMAC100_INT_PHYSTS_CHG)) {
-		if (net_ratelimit())
+		if (net_ratelimit() && FTMAC100_DEBUG)
 			netdev_info(netdev, "[ISR] = 0x%x: %s%s%s%s\n", status,
 				    status & FTMAC100_INT_NORXBUF ? "NORXBUF " : "",
 				    status & FTMAC100_INT_RPKT_LOST ? "RPKT_LOST " : "",
@@ -969,6 +1012,15 @@ static int ftmac100_open(struct net_device *netdev)
 		goto err_irq;
 	}
 
+	// set sysctl ip fragmentation parameters.
+	// sysctl -w net.ipv4.ipfrag_time
+	// sysctl -w net.ipv4.ipfrag_high_thresh
+	struct net *net;
+
+	net = dev_net(netdev);
+	net->ipv4.fqdir->timeout = (5 * HZ);		/* Decrease fragment timeout, 30 -> 5 */
+	net->ipv4.fqdir->high_thresh = 8 * 1024 * 1024;  /* Increase fragment buffer size, 4M -> 8M */
+
 	priv->rx_pointer = 0;
 	priv->tx_clean_pointer = 0;
 	priv->tx_pointer = 0;
@@ -1007,7 +1059,7 @@ static int ftmac100_stop(struct net_device *netdev)
 	return 0;
 }
 
-static netdev_tx_t
+static int
 ftmac100_hard_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
 	struct ftmac100 *priv = netdev_priv(netdev);
@@ -1197,6 +1249,58 @@ static int ftmac100_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int ftmac100_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *netdev = platform_get_drvdata(pdev);
+	struct ftmac100 *priv = netdev_priv(netdev);
+
+	if (!netif_running(netdev))
+		return 0;
+
+	pr_info("ftmac100_suspend() ...\n");
+
+	ftmac100_disable_all_int(priv);
+
+	netif_stop_queue(netdev);
+
+	napi_disable(&priv->napi);
+
+	netif_tx_lock(netdev);
+	netif_device_detach(netdev);
+	netif_tx_unlock(netdev);
+
+	ftmac100_stop_hw(priv);
+
+	return 0;
+}
+
+static int ftmac100_resume(struct platform_device *pdev)
+{
+	struct net_device *netdev = platform_get_drvdata(pdev);
+	struct ftmac100 *priv = netdev_priv(netdev);
+
+	if (!netif_running(netdev))
+		return 0;
+
+	pr_info("ftmac100_resume() ...\n");
+
+	iowrite32(MACCR_ENABLE_ALL, priv->base + FTMAC100_OFFSET_MACCR);
+
+	napi_enable(&priv->napi);
+
+	netif_tx_lock(netdev);
+	netif_device_attach(netdev);
+	netif_tx_unlock(netdev);
+
+	netif_start_queue(netdev);
+
+	ftmac100_enable_all_int(priv);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
 static const struct of_device_id ftmac100_of_ids[] = {
 	{ .compatible = "andestech,atmac100" },
 	{ }
@@ -1209,6 +1313,10 @@ static struct platform_driver ftmac100_driver = {
 		.name	= DRV_NAME,
 		.of_match_table = ftmac100_of_ids
 	},
+#ifdef CONFIG_PM
+	.suspend	= ftmac100_suspend,
+	.resume		= ftmac100_resume,
+#endif /* CONFIG_PM */
 };
 
 /******************************************************************************
diff --git a/drivers/net/ethernet/faraday/ftmac100.h b/drivers/net/ethernet/faraday/ftmac100.h
index 8af32f9070f4..4269b0c1400a 100644
--- a/drivers/net/ethernet/faraday/ftmac100.h
+++ b/drivers/net/ethernet/faraday/ftmac100.h
@@ -4,6 +4,19 @@
  *
  * (C) Copyright 2009-2011 Faraday Technology
  * Po-Yu Chuang <ratbert@faraday-tech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this progra.
  */
 
 #ifndef __FTMAC100_H
@@ -22,6 +35,8 @@
 #define	FTMAC100_OFFSET_ITC		0x28
 #define	FTMAC100_OFFSET_APTC		0x2c
 #define	FTMAC100_OFFSET_DBLAC		0x30
+#define	FTMAC100_OFFSET_TXR_BADR_H	0x40
+#define	FTMAC100_OFFSET_RXR_BADR_H	0x44
 #define	FTMAC100_OFFSET_MACCR		0x88
 #define	FTMAC100_OFFSET_MACSR		0x8c
 #define	FTMAC100_OFFSET_PHYCR		0x90
@@ -42,9 +57,7 @@
 #define	FTMAC100_OFFSET_RP		0xf4
 #define	FTMAC100_OFFSET_XP		0xf8
 
-/*
- * Interrupt status register & interrupt mask register
- */
+/* Interrupt status register & interrupt mask register */
 #define	FTMAC100_INT_RPKT_FINISH	(1 << 0)
 #define	FTMAC100_INT_NORXBUF		(1 << 1)
 #define	FTMAC100_INT_XPKT_FINISH	(1 << 2)
@@ -56,9 +69,7 @@
 #define	FTMAC100_INT_AHB_ERR		(1 << 8)
 #define	FTMAC100_INT_PHYSTS_CHG		(1 << 9)
 
-/*
- * Interrupt timer control register
- */
+/* Interrupt timer control register */
 #define FTMAC100_ITC_RXINT_CNT(x)	(((x) & 0xf) << 0)
 #define FTMAC100_ITC_RXINT_THR(x)	(((x) & 0x7) << 4)
 #define FTMAC100_ITC_RXINT_TIME_SEL	(1 << 7)
@@ -66,17 +77,13 @@
 #define FTMAC100_ITC_TXINT_THR(x)	(((x) & 0x7) << 12)
 #define FTMAC100_ITC_TXINT_TIME_SEL	(1 << 15)
 
-/*
- * Automatic polling timer control register
- */
+/* Automatic polling timer control register */
 #define	FTMAC100_APTC_RXPOLL_CNT(x)	(((x) & 0xf) << 0)
 #define	FTMAC100_APTC_RXPOLL_TIME_SEL	(1 << 4)
 #define	FTMAC100_APTC_TXPOLL_CNT(x)	(((x) & 0xf) << 8)
 #define	FTMAC100_APTC_TXPOLL_TIME_SEL	(1 << 12)
 
-/*
- * DMA burst length and arbitration control register
- */
+/* DMA burst length and arbitration control register */
 #define FTMAC100_DBLAC_INCR4_EN		(1 << 0)
 #define FTMAC100_DBLAC_INCR8_EN		(1 << 1)
 #define FTMAC100_DBLAC_INCR16_EN	(1 << 2)
@@ -84,9 +91,7 @@
 #define FTMAC100_DBLAC_RXFIFO_HTHR(x)	(((x) & 0x7) << 6)
 #define FTMAC100_DBLAC_RX_THR_EN	(1 << 9)
 
-/*
- * MAC control register
- */
+/* MAC control register */
 #define	FTMAC100_MACCR_XDMA_EN		(1 << 0)
 #define	FTMAC100_MACCR_RDMA_EN		(1 << 1)
 #define	FTMAC100_MACCR_SW_RST		(1 << 2)
@@ -104,28 +109,22 @@
 #define	FTMAC100_MACCR_RX_MULTIPKT	(1 << 16)
 #define	FTMAC100_MACCR_RX_BROADPKT	(1 << 17)
 
-/*
- * PHY control register
- */
+/* PHY control register */
 #define FTMAC100_PHYCR_MIIRDATA		0xffff
 #define FTMAC100_PHYCR_PHYAD(x)		(((x) & 0x1f) << 16)
 #define FTMAC100_PHYCR_REGAD(x)		(((x) & 0x1f) << 21)
 #define FTMAC100_PHYCR_MIIRD		(1 << 26)
 #define FTMAC100_PHYCR_MIIWR		(1 << 27)
 
-/*
- * PHY write data register
- */
+/* PHY write data register */
 #define FTMAC100_PHYWDATA_MIIWDATA(x)	((x) & 0xffff)
 
-/*
- * Transmit descriptor, aligned to 16 bytes
- */
+/* Transmit descriptor, aligned to 16 bytes */
 struct ftmac100_txdes {
-	__le32		txdes0;
-	__le32		txdes1;
-	__le32		txdes2;	/* TXBUF_BADR */
-	unsigned int	txdes3;	/* not used by HW */
+	unsigned int	txdes0;
+	unsigned int	txdes1;
+	unsigned int	txdes2;	/* TXBUF_BADR */
+	unsigned int	txdes3;	/* TXBUF_BADR_H */
 } __attribute__ ((aligned(16)));
 
 #define	FTMAC100_TXDES0_TXPKT_LATECOL	(1 << 0)
@@ -139,14 +138,12 @@ struct ftmac100_txdes {
 #define	FTMAC100_TXDES1_TXIC		(1 << 30)
 #define	FTMAC100_TXDES1_EDOTR		(1 << 31)
 
-/*
- * Receive descriptor, aligned to 16 bytes
- */
+/* Receive descriptor, aligned to 16 bytes */
 struct ftmac100_rxdes {
-	__le32		rxdes0;
-	__le32		rxdes1;
-	__le32		rxdes2;	/* RXBUF_BADR */
-	unsigned int	rxdes3;	/* not used by HW */
+	unsigned int	rxdes0;
+	unsigned int	rxdes1;
+	unsigned int	rxdes2;	/* RXBUF_BADR */
+	unsigned int	rxdes3;	/* RXBUF_BADR_H */
 } __attribute__ ((aligned(16)));
 
 #define	FTMAC100_RXDES0_RFL		0x7ff
@@ -164,4 +161,12 @@ struct ftmac100_rxdes {
 #define	FTMAC100_RXDES1_RXBUF_SIZE(x)	((x) & 0x7ff)
 #define	FTMAC100_RXDES1_EDORR		(1 << 31)
 
+struct ftmac100_txdes_ext {
+	void *skb;
+};
+
+struct ftmac100_rxdes_ext {
+	void *page;
+};
+
 #endif /* __FTMAC100_H */
diff --git a/drivers/net/ethernet/faraday/ftmac100_debug.c b/drivers/net/ethernet/faraday/ftmac100_debug.c
new file mode 100644
index 000000000000..a2db0f2aa338
--- /dev/null
+++ b/drivers/net/ethernet/faraday/ftmac100_debug.c
@@ -0,0 +1,193 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *  Copyright (C) 2009 Andes Technology Corporation
+ *  Copyright (C) 2019 Andes Technology Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/blkdev.h>
+#include <linux/proc_fs.h>
+
+#define INPUTLEN 32
+
+/* 0: DISABLE
+ * 1: ENABLE
+ */
+unsigned int FTMAC100_DEBUG;
+
+/* 0: DISABLE
+ * 1: INCR4
+ * 2: INCR8
+ * 4: INCR16
+ */
+unsigned int FTMAC100_INCR;
+
+#define ENTRY_NUMBER 2
+
+struct entry_struct {
+	char *name;
+	int perm;
+	const struct proc_ops *p_ops;
+};
+
+static struct proc_dir_entry *proc_ftmac100_debug;
+
+#define DEBUG(enable, tagged, ...)                               \
+	do {                                                     \
+		if (enable) {                                    \
+			if (tagged)                              \
+				printk("[ %30s() ] ", __func__); \
+			printk(__VA_ARGS__);                     \
+		}                                                \
+	} while (0)
+
+static int debug;
+module_param(debug, int, 0);
+
+static ssize_t ftmac100_proc_read(struct file *file, char __user *userbuf,
+				  size_t count, loff_t *ppos)
+{
+	int ret = 0;
+	char buf[128] = {0};
+
+	if (!strncmp(file->f_path.dentry->d_name.name, "debug", 5)) {
+		ret = sprintf(buf, "FTMAC100 debug info: %s\n",
+			      (FTMAC100_DEBUG) ? "Enabled" : "Disabled");
+	} else if (!strncmp(file->f_path.dentry->d_name.name, "incr", 4)) {
+		switch (FTMAC100_INCR) {
+		case 0:
+			ret = sprintf(buf, "FTMAC100 INCR: %s\n", "Disabled");
+			break;
+		case 1:
+			ret = sprintf(buf, "FTMAC100 INCR: %d (INCR4)\n",
+				      FTMAC100_INCR);
+			break;
+		case 2:
+			ret = sprintf(buf, "FTMAC100 INCR: %d (INCR8)\n",
+				      FTMAC100_INCR);
+			break;
+		case 4:
+			ret = sprintf(buf, "FTMAC100 INCR: %d (INCR16)\n",
+				      FTMAC100_INCR);
+			break;
+		}
+	} else
+		return -EFAULT;
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, ret);
+}
+
+static ssize_t ftmac100_proc_write(struct file *file, const char __user *buffer,
+				   size_t count, loff_t *ppos)
+{
+	unsigned long en;
+	char inbuf[INPUTLEN];
+
+	if (count > INPUTLEN - 1)
+		count = INPUTLEN - 1;
+
+	if (copy_from_user(inbuf, buffer, count))
+		return -EFAULT;
+
+	inbuf[count] = '\0';
+
+	if (!sscanf(inbuf, "%lu", &en))
+		return -EFAULT;
+
+	if (!strncmp(file->f_path.dentry->d_name.name, "debug", 5)) {
+		FTMAC100_DEBUG = en;
+	} else if (!strncmp(file->f_path.dentry->d_name.name, "incr", 4)) {
+		switch (en) {
+		case 0:
+		case 1:
+		case 2:
+		case 4:
+			FTMAC100_INCR = en;
+			printk("Please restart eth0 interface to apply INCR\n");
+			printk("    ~# ifconfig eth0 down\n");
+			printk("    ~# udhcpc\n");
+			break;
+		default:
+			printk("INCR value must be [0/1/2/4]\n");
+			printk("    0: INCR disabled\n");
+			printk("    1: INCR4\n");
+			printk("    2: INCR8\n");
+			printk("    4: INCR16\n");
+		}
+	} else {
+		return -EFAULT;
+	}
+
+	return count;
+}
+
+static const struct proc_ops en_fops = {
+	.proc_open = simple_open,
+	.proc_read = ftmac100_proc_read,
+	.proc_write = ftmac100_proc_write,
+};
+
+static void create_seq_entry(struct entry_struct *e, mode_t mode,
+			     struct proc_dir_entry *parent)
+{
+	struct proc_dir_entry *entry =
+		proc_create(e->name, mode, parent, e->p_ops);
+
+	if (!entry)
+		printk(KERN_ERR "invalid %s register.\n", e->name);
+}
+
+static void install_proc_table(struct entry_struct *table)
+{
+	int i;
+
+	for (i = 0; i < ENTRY_NUMBER; table++, i++)
+		create_seq_entry(table, table->perm, proc_ftmac100_debug);
+}
+
+static void remove_proc_table(struct entry_struct *table)
+{
+	int i;
+
+	for (i = 0; i < ENTRY_NUMBER; table++, i++)
+		remove_proc_entry(table->name, proc_ftmac100_debug);
+}
+
+struct entry_struct proc_table_ftmac100_debug[ENTRY_NUMBER] = {
+	{"debug", 0644, &en_fops},
+	{"incr", 0644, &en_fops},
+};
+
+static int __init init_ftmac100_debug(void)
+{
+	FTMAC100_DEBUG = 0;
+	FTMAC100_INCR = 4;
+	debug = 0;
+	DEBUG(debug, 1, "ftmac100_debug module registered\n");
+
+	proc_ftmac100_debug = proc_mkdir("ftmac100_debug", NULL);
+	if (!proc_ftmac100_debug)
+		return -ENOMEM;
+
+	install_proc_table(proc_table_ftmac100_debug);
+
+	return 0;
+}
+
+static void __exit cleanup_ftmac100_debug(void)
+{
+	remove_proc_table(proc_table_ftmac100_debug);
+	remove_proc_entry("ftmac100_debug", NULL);
+
+	DEBUG(debug, 1, "ftmac100_debug module unregistered\n");
+}
+
+module_init(init_ftmac100_debug);
+module_exit(cleanup_ftmac100_debug);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ftmac100_debug Module");
-- 
2.34.1

